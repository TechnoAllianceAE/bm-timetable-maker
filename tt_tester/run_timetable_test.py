#!/usr/bin/env python3
"""
Run timetable generation tests using CSV data generated by data_generator.py
"""

import csv
import json
import requests
from pathlib import Path
from datetime import datetime

def load_csv_data(tt_id):
    """Load CSV data for a given TT ID"""
    base_path = Path(__file__).parent

    # First, load subjects to create code->name mapping
    subject_code_to_name = {}
    subjects = []
    with open(base_path / f"data_subjects_{tt_id}.csv", 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            subject_code_to_name[row['code']] = row['name']
            subjects.append({
                "id": f"sub-{row['code'].lower()}",
                "school_id": "test-school",
                "name": row['name'],
                "code": row['code'],
                "periods_per_week": int(row['periods_per_week']),
                "requires_lab": row['needs_lab'] == 'True',
                "is_elective": False
            })

    # Load classes
    classes = []
    with open(base_path / f"data_classes_{tt_id}.csv", 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            classes.append({
                "id": row['class_id'],
                "school_id": "test-school",
                "name": row['name'],
                "grade": int(row['grade']),
                "section": row['section'],
                "student_count": int(row['capacity'])
            })

    # Load teachers - convert subject codes to names
    teachers = []
    with open(base_path / f"data_teachers_{tt_id}.csv", 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            subject_codes = row['subjects_qualified'].split(',')
            # Convert codes to names (e.g., "MATH" -> "Mathematics")
            subject_names = [subject_code_to_name.get(code.strip(), code.strip()) for code in subject_codes]
            teachers.append({
                "id": row['teacher_id'],
                "user_id": row['teacher_id'],
                "subjects": subject_names,
                "max_periods_per_day": int(row['max_periods_per_day']),
                "max_periods_per_week": int(row['max_periods_per_week']),
                "max_consecutive_periods": 3
            })

    # Load rooms (from data_rooms CSV)
    rooms = []
    with open(base_path / f"data_rooms_{tt_id}.csv", 'r') as f:
        reader = csv.DictReader(f)
        for idx, row in enumerate(reader):
            room_type = row['type'].upper() if row['type'].upper() in ['CLASSROOM', 'LAB', 'AUDITORIUM'] else 'CLASSROOM'
            facilities = []
            if row.get('has_projector') == 'True':
                facilities.append('projector')
            if row.get('specialization'):
                facilities.append(row['specialization'])

            rooms.append({
                "id": row['room_id'],
                "school_id": "test-school",
                "name": row['name'],
                "building": "Main Building",
                "floor": (idx // 10) + 1,  # Assign floors based on room number
                "capacity": int(row['capacity']),
                "type": room_type,
                "facilities": facilities
            })

    # Load assignments
    assignments = []
    with open(base_path / f"data_assignments_{tt_id}.csv", 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            assignments.append({
                "id": row['assignment_id'],
                "teacher_id": row['teacher_id'],
                "class_id": row['class_id'],
                "subject_code": row['subject_code'],
                "periods_per_week": int(row['periods_per_week'])
            })

    # Create time slots (40 per week = 5 days √ó 8 periods)
    time_slots = []
    days = ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY"]
    for day_idx, day in enumerate(days):
        for period in range(1, 9):
            time_slots.append({
                "id": f"slot-{day_idx * 8 + period}",
                "school_id": "test-school",
                "day_of_week": day,
                "period_number": period,
                "start_time": f"{7 + period}:00",
                "end_time": f"{8 + period}:00",
                "is_break": False
            })

    # Create constraints list (NO_GAPS is critical for classes)
    constraints = [
        {
            "id": "constraint-1",
            "school_id": "test-school",
            "type": "NO_GAPS",
            "priority": "MANDATORY",
            "entity_type": "CLASS",
            "entity_id": None,
            "parameters": {},
            "description": "Classes must have no gaps in their schedules"
        }
    ]

    return {
        "school_id": "test-school",
        "academic_year_id": "2025-2026",
        "tt_generation_id": tt_id,
        "classes": classes,
        "teachers": teachers,
        "subjects": subjects,
        "rooms": rooms,
        "time_slots": time_slots,
        "assignments": assignments,
        "constraints": constraints,
        "options": 3,
        "timeout": 120
    }

def generate_timetable(tt_id, api_url="http://localhost:8000"):
    """Generate timetable for given TT ID"""
    print(f"\n{'='*60}")
    print(f"üöÄ Generating Timetable for {tt_id}")
    print(f"{'='*60}\n")

    # Load data
    print("üìÇ Loading CSV data...")
    request_data = load_csv_data(tt_id)

    print(f"   Classes: {len(request_data['classes'])}")
    print(f"   Teachers: {len(request_data['teachers'])}")
    print(f"   Subjects: {len(request_data['subjects'])}")
    print(f"   Rooms: {len(request_data['rooms'])}")
    print(f"   Assignments: {len(request_data['assignments'])}")
    print(f"   Time Slots: {len(request_data['time_slots'])}")

    # Send to timetable engine
    print(f"\nüîÑ Sending to timetable engine at {api_url}/generate...")
    start_time = datetime.now()

    try:
        response = requests.post(
            f"{api_url}/generate",
            json=request_data,
            timeout=120
        )

        elapsed = (datetime.now() - start_time).total_seconds()
        print(f"‚è±Ô∏è  Generation time: {elapsed:.2f}s")

        if response.status_code == 200:
            result = response.json()

            # Save result
            result_file = Path(__file__).parent / f"result_{tt_id}.json"
            with open(result_file, 'w') as f:
                json.dump(result, f, indent=2)

            print(f"\n‚úÖ SUCCESS!")
            print(f"   Status: {result.get('status')}")
            print(f"   Message: {result.get('message', 'N/A')}")

            if 'schedules' in result:
                print(f"   Schedules generated: {len(result['schedules'])}")
                total_slots = sum(len(s.get('slots', [])) for s in result['schedules'])
                print(f"   Total slots scheduled: {total_slots}")

            if 'diagnostics' in result:
                diag = result['diagnostics']
                print(f"\nüìä Diagnostics:")
                print(f"   Total assignments: {diag.get('total_assignments', 0)}")
                print(f"   Scheduled: {diag.get('scheduled_assignments', 0)}")
                print(f"   Coverage: {diag.get('coverage_percentage', 0):.1f}%")

            print(f"\nüíæ Result saved to: {result_file}")
            return result

        else:
            print(f"\n‚ùå FAILED!")
            print(f"   Status code: {response.status_code}")
            print(f"   Response: {response.text}")
            return None

    except requests.exceptions.Timeout:
        print(f"\n‚è∞ TIMEOUT after {elapsed:.2f}s")
        return None
    except Exception as e:
        print(f"\nüí• ERROR: {str(e)}")
        return None

if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python3 run_timetable_test.py <TT_ID> [api_url]")
        print("Example: python3 run_timetable_test.py TT_20250930_155334_8fd6ea32")
        sys.exit(1)

    tt_id = sys.argv[1]
    api_url = sys.argv[2] if len(sys.argv) > 2 else "http://localhost:8000"

    result = generate_timetable(tt_id, api_url)
    sys.exit(0 if result else 1)